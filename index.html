<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>game</title>
</head>
<div id="gameView"></div>
<table>
    <tr>
        <td>名字</td>
        <td id="name"></td>
    </tr>
    <tr>
        <td>裝備</td>
        <td id="equip"></td>
    </tr>
    <tr>
        <td>attack count</td>
        <td id="attack_count"></td>
    </tr>
</table>
<div id="e_move">Enemy Move</div>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="js/pixi.js/bin/pixi.min.js"></script>
<script src="js/greensock-js/src/minified/TweenLite.min.js"></script>
<script src="js/greensock-js/src/minified/TweenMax.min.js"></script>

<script src="js/greensock-js/src/minified/easing/EasePack.min.js"></script>
<script src="js/datas.js"></script>
<script src="js/helps.js"></script>
<script src="js/core.js"></script>
<script src="js/attack_model.js"></script>
<script>
var tempLanguageCombination; //語言組合

window.addEventListener('keydown', languageCombination);

var arrTimer = new Array(); //時間倒數物件
var arrRoleObj = new Array(); //角色物件

var totalRoom = 0; //總房間數

var currentRole; //目前操作的腳色
var attackButtom = new Array();

var attackMode = false;
//block size
var blockWidth = 200;
var blockHeight = 200;
var t = 0;


var displayWidth = 750;
var displayHeight = 500;

// create the root of the scene graph
var gameStage;
var renderer;
//增加容器
var mapLayer;
var mapTexture = PIXI.Texture.fromImage('images/tilemap.png');
var cameraFollow = false;

var dragMap = true;
var stage = new PIXI.Container();
/*game stage*/
var gameStage = new PIXI.Container(); //主場景
var mapLayer = new PIXI.Container(); //地圖
var enemyLayer = new PIXI.Container(); //敵人
var playerLayer = new PIXI.Container(); //玩家
var itemLayer = new PIXI.Container(); //物件
var passageLayer = new PIXI.Container(); //物件
var actionUiLayer = new PIXI.Container(); //人物ui

/*main ui*/
var mainUiLayer = new PIXI.Container();
var statusLayer = new PIXI.Container();//

gameStage.updateLayersOrder = function() {
    gameStage.children.sort(function(a, b) {
        a.zIndex = a.zIndex || 0;
        b.zIndex = b.zIndex || 0;
        return a.zIndex - b.zIndex
    });
};


gameStage.interactive = true;

stage.addChild(gameStage);
stage.addChild(mainUiLayer);
stage.addChild(statusLayer);

mapLayer.zIndex = 10;
itemLayer.zIndex = 20;
enemyLayer.zIndex = 30;
playerLayer.zIndex = 40;
passageLayer.zIndex = 50;
actionUiLayer.zIndex = 60;

gameStage.addChild(playerLayer);
gameStage.addChild(itemLayer);
gameStage.addChild(actionUiLayer);
gameStage.addChild(enemyLayer);
gameStage.addChild(passageLayer);
gameStage.addChild(mapLayer);


gameStage.updateLayersOrder();
displayAp();
createUiBtn();

init();




/*
var t2 = new countdown();
t2.process = function(){
    console.log(this.percent);
}

arrTimer.push(t2);

*/


function init() {
   
    renderer = PIXI.autoDetectRenderer(displayWidth, displayHeight, {
        backgroundColor: 0x1099bb
    });

    document.getElementById("gameView").appendChild(renderer.view);

    //增加容器 
    createMap();

    var cR = new createRole();
    cR._roleTypeObj = arrRoleType[0];
    cR._faction = "enemy";
    for (var i = 0; i < 40; i++) {
        cR._roleLocal = null;
        var _enemy = cR.create();
        _enemy.visible = false;

        enemyLayer.addChild(_enemy);

    }

    var cR = new createRole();
    cR._roleTypeObj = arrRoleType[1];
    cR._faction = "player";
    cR._roleLocal = getMapInfo(arrMap, {
        room_id: "f"
    })[0];
    var newR = cR.create();
    playerLayer.addChild(newR);


    newR.interactive = true;
    newR.buttonMode = true;

    newR.skill = [];
    newR.equip = {
        main: [0, 1],
        sub: []
    };



    newR.actionPoint = 3;
    //取得視野
    newR.panorama = getPanorama(newR.local.room_id, 0, 5);

    for (var i = 0; i < newR.panorama.length; i++) {

        objectHelp(enemyLayer.children, {

            local: newR.panorama[i]
        }, {
            visible: true
        });

    }

    currentRole = newR;
    createStatus();
    /*
        var menu = new PIXI.Container();
        menu
        var bgbg = new PIXI.Graphics();

        bgbg.beginFill(0x333333, 0.5);
        bgbg.drawRect(0, 0, 600, 600);
        menu.addChild(bgbg);
        var bt = new PIXI.Graphics();

        bt.beginFill(0xFF0000, 1);
        bt.drawRect(0, 0, 100, 100);
        bt.buttonMode = true;
        bt.interactive = true;
        menu.addChild(bt);

        bt.on('mousedown', testB);

        menu.interactive = true;
        gameStage.addChild(menu);

        menu.on('mousedown', testM);

        function testM(event) {
           
            var thisM = event.data;
            var _x = thisM.getLocalPosition(this).x;
            var _y = thisM.getLocalPosition(this).y;
           
           if((_x < bt.x || _x> bt.x+bt.width) && (_y < bt.y || _y> bt.y+bt.height)){
                console.log("out");
           }



        }

        function testB(event) {
            console.log(this);
        }
    */

    objectHelp(gameStage.children)


    /**/
    var getInitCurrentPlayer = objectHelp(playerLayer.children, {
        faction: "player"
    })[0];
    moveToTarget(getInitCurrentPlayer.x, getInitCurrentPlayer.y);

    /*
         var cR = new createRole();
        cR._roleTypeObj = arrRoleType[1];
        cR._faction = "player";
        cR._roleLocal = "q";
        var newR = cR.create();
    */
    /*newR.oX = newR.position.x;
    newR.oY = newR.position.y;
    newR.at = 2000;
    newR.endTime = new Date().getTime() + newR.at;

    newR.startTime = new Date().getTime();*/

    /* var aass =findEnemyByNoise();
     console.log(aass);*/


    $('#e_move').click(function() {
        enemyMove();
    })

    newR.on('mousedown', roleClick);

    //enemyMove();
    if (dragMap) {
        gameStage.on('mousedown', onDragStart)
            .on('touchstart', onDragStart)
            // events for drag end
            .on('mouseup', onDragEnd)
            .on('mouseupoutside', onDragEnd)
            .on('touchend', onDragEnd)
            .on('touchendoutside', onDragEnd)
            // events for drag move
            .on('mousemove', onDragMove)
            .on('touchmove', onDragMove);
    }


    /*拖拉地圖*/

    //gameStage.on('mousewheel',onWheel);

   // document.getElementById('gameView').addEventListener("mousewheel", onWheel, false);

    // gridLayer.anchor.set(0.5);// graphics.pivot , sprite.anchor    


    function onDragStart(event) {
        // store a reference to the data
        // the reason for this is because of multitouch
        // we want to track the movement of this particular touch
        this.data = event.data;
        //this.alpha = 0.5;
        this.dragging = true;
        this.sx = this.data.getLocalPosition(this).x * this.scale.x;
        this.sy = this.data.getLocalPosition(this).y * this.scale.y;


    }

    function onDragEnd() {
        this.alpha = 1;

        this.dragging = false;

        // set the interaction data to null
        this.data = null;
    }

    function onDragMove() {

        if (this.dragging) {
            var newPosition = this.data.getLocalPosition(this.parent);
            this.position.x = newPosition.x - this.sx;
            this.position.y = newPosition.y - this.sy;

        }
    }

    function onWheel(event) {
        // console.log(event);
        if (event.wheelDelta < 1) {
            gameStage.scale.x -= 0.1;
            gameStage.scale.y -= 0.1;
        } else {
            gameStage.scale.x += 0.1;
            gameStage.scale.y += 0.1;
        }
    }


    //gameStage.addChild(mapLayer);
    animate();
}



// アニメーション関数を定義する
function animate() {
    requestAnimFrame(animate);
    renderer.render(stage);

    /*  tilingSprite.tilePosition.x += 1;
      tilingSprite.tilePosition.y += 1;*/

    for (var i = 0; i < arrTimer.length; i++) {
        //console.log(arrTimer.length);
        if (arrTimer[i].play()) {
            arrTimer.splice(i, 1);
        }

    }

    for (var i = 0; i < arrRoleObj.length; i++) {

/*
        if (arrRoleObj[i].actionMovement == true) {

            //var _de = (new Date().getTime() - arrRoleObj[i].startTime) / arrRoleObj[i].at * 100;

            var _speed = 5;

            var _dy = arrRoleObj[i].goalY - arrRoleObj[i].position.y;
            var _dx = arrRoleObj[i].goalX - arrRoleObj[i].position.x;

            var _radian = Math.atan2(_dy, _dx);


            if (Math.sqrt(_dy * _dy + _dx * _dx) < _speed) {
                arrRoleObj[i].position.x = arrRoleObj[i].goalX;
                arrRoleObj[i].position.y = arrRoleObj[i].goalY;
                arrRoleObj[i].actionMovement = false;
            } else {
                arrRoleObj[i].position.x += Math.cos(_radian) * _speed;
                arrRoleObj[i].position.y += Math.sin(_radian) * _speed;
            }


        }
*/


        /*  var _rotation = Math.atan2(arrRoleObj[i].position.y - arrRoleObj[i].goalY, arrRoleObj[i].position.x - arrRoleObj[i].goalX);
          console.log(Math.cos(_rotation));*/
        // Move towards the player
        /* arrRoleObj[i].position.x += Math.cos(_rotation);
         arrRoleObj[i].position.y += Math.sin(_rotation);*/
    }

    /*  if (gameStage.actionMovement == true) {
           var _speed = 5;

           var _dy = gameStage.goalY - gameStage.position.y;
           var _dx = gameStage.goalX - gameStage.position.x;

           var _radian = Math.atan2(_dy, _dx);


           if (Math.sqrt(_dy * _dy + _dx * _dx) < _speed) {
               gameStage.position.x = gameStage.goalX;
               gameStage.position.y = gameStage.goalY;
               gameStage.actionMovement = false;
           } else {
               gameStage.position.x += Math.cos(_radian) * _speed;
               gameStage.position.y += Math.sin(_radian) * _speed;
           }

      }*/


}



//以後參考
//graphics.hitTest = graphics.getBounds();
</script>
</body>

</html>
